import { css, SimpleInterpolation } from 'styled-components';

import { appsTheme } from './theme';
import { TypographyProps, TypographySize, TypographyType } from './types';

export const getTypographyRuleMixins = (
  size: TypographySize,
  type: TypographyType,
) => {
  const sizeBranch = appsTheme[size];

  if (!size || !type) {
    throw new Error(
      `Apps typography: type ${type} and size ${size} is not valid configuration`,
    );
  }

  if (!(type in sizeBranch)) {
    throw new Error(
      `Apps typography: ${type} variant is not supported for ${size} typography`,
    );
  }
  const variantBranch =
    sizeBranch[type as Extract<keyof typeof sizeBranch, TypographyType>];

  return {
    fontSize: sizeBranch.size,
    lineHeight: sizeBranch.lineHeight,
    color: variantBranch.color,
    fontWeight: variantBranch.weight,
  };
};

const isProps = (arg1: unknown, arg2: unknown): arg1 is TypographyProps => {
  return arg1 !== undefined && arg2 === undefined;
};

/* eslint-disable no-redeclare */
export function typographyMixin(
  props: TypographyProps,
): ReadonlyArray<SimpleInterpolation>;
export function typographyMixin(
  size: TypographySize,
  type: TypographyType,
): ReadonlyArray<SimpleInterpolation>;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function typographyMixin(arg1: any, arg2?: any) {
  const size = isProps(arg1, arg2) ? arg1.size : (arg1 as TypographySize);
  const type = isProps(arg1, arg2) ? arg1.type : (arg2 as TypographyType);

  const mixins = getTypographyRuleMixins(size, type);

  return css`
    font-size: ${mixins.fontSize};
    line-height: ${mixins.lineHeight};
    color: ${mixins.color};
    font-weight: ${mixins.fontWeight};
  `;
}
