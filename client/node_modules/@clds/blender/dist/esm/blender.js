import { normal } from 'color-blend';
import { parseToRgb, rgba, rgbToColorString } from 'polished';
import { backgroundMapping, foregroundMapping } from './mapping';
const toColorBlendRgba = (color) => ({
    r: color.red,
    g: color.green,
    b: color.blue,
    a: 'alpha' in color ? color.alpha : 1,
});
const fromBlendToPolishedRgba = (color) => ({
    red: color.r,
    green: color.g,
    blue: color.b,
    alpha: color.a,
});
const toPolishedRgba = (color) => color === 'transparent'
    ? { red: 255, green: 255, blue: 255, alpha: 0 }
    : parseToRgb(color);
export const resolveColor = (color, colors) => (color === 'transparent' ? 'transparent' : colors[color]);
const computeBlendColor = (blending, colors) => {
    const baseColor = resolveColor(blending.baseColor, colors);
    const blendColor = rgba(resolveColor(blending.blendColor, colors), blending.blendOpacity);
    const blendBackdrop = toColorBlendRgba(toPolishedRgba(baseColor));
    const blendSource = toColorBlendRgba(toPolishedRgba(blendColor));
    return rgbToColorString(fromBlendToPolishedRgba(normal(blendBackdrop, blendSource)));
};
export const getBackgroundBlendOptions = (props) => backgroundMapping[props.mode][props.variant][props.intensity];
export const getForegroundBlendOptions = (props) => foregroundMapping[props.mode][props.variant];
export const blenderBackground = (props) => computeBlendColor(getBackgroundBlendOptions(props), props.theme.palette);
export const blenderForeground = (props) => resolveColor(getForegroundBlendOptions(props).colorName, props.theme.palette);
export const getBlenderTypographyType = (mode, variant) => foregroundMapping[mode][variant].typography;
//# sourceMappingURL=blender.js.map