/* eslint-disable no-unused-vars */
import {
  ExplicitMixedControlProps,
  ImplicitMixedControlProps,
  ImplicitTraceableMixedControlProps,
} from '../src/MixedControlProps';

describe('MixedControlProps', () => {
  describe('ExplicitMixedControlProps', () => {
    it('should require either setter or default value prop', () => {
      // @ts-expect-error isChecked or defaultChecked required
      const badUsage1: ExplicitMixedControlProps<'checked', boolean> = {};
      // @ts-expect-error isChecked or defaultChecked required
      const badUsage2: ExplicitMixedControlProps<'checked', boolean> = {
        onCheckedChange: () => void 0,
      };
      const goodUsage1: ExplicitMixedControlProps<'checked', boolean> = {
        defaultChecked: true,
      };
      const goodUsage2: ExplicitMixedControlProps<'checked', boolean> = {
        isChecked: true,
      };
    });

    it('should prevent mixing controlled and uncontrolled modes', () => {
      // @ts-expect-error defaultChecked and isChecked can't live together
      const badUsage1: ExplicitMixedControlProps<'checked', boolean> = {
        defaultChecked: true,
        isChecked: true,
      };
      // @ts-expect-error defaultChecked and isChecked can't live together, even if callback is provided
      const badUsage2: ExplicitMixedControlProps<'checked', boolean> = {
        defaultChecked: true,
        isChecked: true,
        onCheckedChange: () => void 0,
      };
    });

    it('the callback is optional for controlled mode but forbidden for uncontrolled mode', () => {
      const goodUsage1: ExplicitMixedControlProps<'checked', boolean> = {
        isChecked: true,
      };
      const goodUsage2: ExplicitMixedControlProps<'checked', boolean> = {
        defaultChecked: true,
      };
      const goodUsage3: ExplicitMixedControlProps<'checked', boolean> = {
        isChecked: true,
        onCheckedChange: (value) => value,
      };
      // @ts-expect-error onCheckedChange can't be together with defaultChecked.
      // We want to prevent abuse of "lifting the state up" principle,
      // for analytics-like callbacks just add it externally
      const badUsage1: ExplicitMixedControlProps<'checked', boolean> = {
        defaultChecked: true,
        onCheckedChange: (value: unknown) => value,
      };
    });

    it('should allow specific fields for controlled mode', () => {
      const controlledModeGood: ExplicitMixedControlProps<'checked', boolean> =
        { isChecked: true, onCheckedChange: (value: boolean) => value };
      const controlledModeBad1: ExplicitMixedControlProps<'checked', boolean> =
        {
          isChecked: true,
          // @ts-expect-error TS2322: Types of parameters 'value' and 'value' are incompatible.
          onCheckedChange: (value: number) => value,
        };
      const controlledModeBad2: ExplicitMixedControlProps<'checked', boolean> =
        {
          // @ts-expect-error TS2322: Type 'number' is not assignable to type 'boolean | undefined'.
          isChecked: 123,
          onCheckedChange: (value: boolean) => value,
        };
    });

    it('should allow specific fields for uncontrolled mode', () => {
      const uncontrolledModeGood: ExplicitMixedControlProps<
        'checked',
        boolean
      > = { defaultChecked: true };
      const uncontrolledModeBad: ExplicitMixedControlProps<'checked', boolean> =
        {
          // @ts-expect-error TS2322: Type 'number' is not assignable to type 'boolean | undefined'.
          defaultChecked: 123,
        };
    });

    it('should follow naming conventions based on field name', () => {
      const controlledGood1: ExplicitMixedControlProps<'foo', string> = {
        foo: 'a',
        onFooChange: (foo: string) => foo,
      };
      const uncontrolledGood1: ExplicitMixedControlProps<'foo', string> = {
        defaultFoo: 'a',
      };
      const controlledGood2: ExplicitMixedControlProps<'value', string> = {
        value: 'a',
        onChange: (value: string) => value,
      };
      const uncontrolledGood2: ExplicitMixedControlProps<'value', string> = {
        defaultValue: 'a',
      };
      const controlledGood3: ExplicitMixedControlProps<'selected', string> = {
        selected: 'a',
        onSelect: (value: string) => value,
      };
      const uncontrolledGood3: ExplicitMixedControlProps<'selected', string> = {
        defaultSelected: 'a',
      };
      const controlledGood4: ExplicitMixedControlProps<'selectedId', string> = {
        selectedId: 'a',
        onSelect: (value: string) => value,
      };
      const uncontrolledGood4: ExplicitMixedControlProps<'selectedId', string> =
        {
          defaultSelectedId: 'a',
        };
      const controlledGood5: ExplicitMixedControlProps<'selectedItem', string> =
        {
          selectedItem: 'a',
          onSelect: (value: string) => value,
        };
      const uncontrolledGood5: ExplicitMixedControlProps<
        'selectedItem',
        string
      > = {
        defaultSelectedItem: 'a',
      };
    });

    it('should follow naming conventions based on value type', () => {
      const stringControlledGood1: ExplicitMixedControlProps<'foo', string> = {
        foo: '1',
        onFooChange: (color: string) => color,
      };
      const stringUncontrolledGood1: ExplicitMixedControlProps<'foo', string> =
        {
          defaultFoo: '1',
        };
      const booleanControlledGood1: ExplicitMixedControlProps<'foo', boolean> =
        {
          isFoo: true,
          onFooChange: (foo: boolean) => foo,
        };
      const booleanUncontrolledGood1: ExplicitMixedControlProps<
        'foo',
        boolean
      > = {
        defaultFoo: true,
      };
    });
  });
  describe('ImplicitMixedControlProps', () => {
    it('should not require any prop to be passed', () => {
      const goodUsage1: ImplicitMixedControlProps<'checked', boolean> = {};
      const goodUsage2: ImplicitMixedControlProps<'checked', boolean> = {
        defaultChecked: true,
      };
      const goodUsage3: ImplicitMixedControlProps<'checked', boolean> = {
        isChecked: true,
      };
      // @ts-expect-error can't use callback outside controlled mode
      const badUsage: ImplicitMixedControlProps<'checked', boolean> = {
        onCheckedChange: () => void 0,
      };
    });
  });

  describe('ImplicitTraceableMixedControlProps', () => {
    it('allows to pass only callback', () => {
      const goodUsage1: ImplicitTraceableMixedControlProps<'checked', boolean> =
        {};
      const goodUsage2: ImplicitTraceableMixedControlProps<'checked', boolean> =
        { defaultChecked: true };
      const goodUsage3: ImplicitTraceableMixedControlProps<'checked', boolean> =
        { isChecked: true };
      const goodUsage4: ImplicitTraceableMixedControlProps<'checked', boolean> =
        { onCheckedChange: (value: boolean) => value };
      const goodUsage5: ImplicitTraceableMixedControlProps<
        'focusedId',
        boolean
      > = {};
    });
  });
});
