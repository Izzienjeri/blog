declare type DefaultValueName<Name extends string> = `default${Capitalize<Name>}`;
interface ExceptionalCallbackNames {
    selected: 'onSelect';
    selectedId: 'onSelect';
    selectedItem: 'onSelect';
    value: 'onChange';
}
declare type AllowedFieldNames = keyof ExceptionalCallbackNames | string;
declare type RegularCallbackName<Name extends string> = `on${Capitalize<Name>}Change`;
declare type CallbackName<Name extends string> = Name extends keyof ExceptionalCallbackNames ? ExceptionalCallbackNames[Name] : RegularCallbackName<Name>;
declare type NormalSetterName<Name extends string> = Name;
declare type BooleanSetterName<Name extends string> = `is${Capitalize<Name>}`;
declare type SetterName<Name extends string, Value> = Value extends boolean ? BooleanSetterName<Name> : NormalSetterName<Name>;
declare type ObjectWithKey<Key extends string, Value> = {
    [key in Key]: Value;
};
declare type ObjectWithOptionalKey<Key extends string, Value> = {
    [key in Key]?: Value;
};
declare type ObjectWithoutKey<Key extends string> = {
    [key in Key]?: never;
};
declare type ExplicitUncontrolledModeProps<Name extends string, Value> = ObjectWithoutKey<SetterName<Name, Value>> & ObjectWithoutKey<CallbackName<Name>> & ObjectWithKey<DefaultValueName<Name>, Value>;
declare type ImplicitUncontrolledModeProps<Name extends string, Value> = ObjectWithoutKey<SetterName<Name, Value>> & ObjectWithoutKey<CallbackName<Name>> & ObjectWithOptionalKey<DefaultValueName<Name>, Value>;
declare type ImplicitTraceableUncontrolledModeProps<Name extends string, Value> = ObjectWithoutKey<SetterName<Name, Value>> & ObjectWithOptionalKey<CallbackName<Name>, (value: Value) => void> & ObjectWithOptionalKey<DefaultValueName<Name>, Value>;
declare type ControlledModeProps<Name extends string, Value> = ObjectWithKey<SetterName<Name, Value>, Value> & ObjectWithOptionalKey<CallbackName<Name>, (value: Value) => void> & ObjectWithoutKey<DefaultValueName<Name>>;
/**
 * Type that describes props that either controls the value by providing setter and callback (ie. color, onColorChange)
 * or leaves control to the component (uncontrolled mode) by providing only default value (ie. defaultColor)
 * This is explicit choice so you can't observe the internal state change if you don't control it, you can't provide too
 * nothing since we want the consumer to be aware of the mixed control mode.
 *
 *
 * @example
 * Replaces manual mixed control types like
 * @code
 * export type DropdownMenuProps = DropdownMenuBaseProps &
 *   (
 *     | { // In controlled mode, controls opened state
 *         isOpened?: never;
 *         onOpenedChange?: never;
 *         defaultOpened: boolean;
 *       }
 *     | { // In uncontrolled mode, sets default opened state
 *         isOpened: boolean;
 *         onOpenedChange?: (value: boolean) => void;
 *         defaultOpened?: never;
 *       }
 *   );
 *
 *   with generic type:
 *   @code
 *   export type DropdownMenuProps = DropdownMenuBaseProps & Controlled<'opened', boolean>
 */
export declare type ExplicitMixedControlProps<Name extends AllowedFieldNames, Value> = ExplicitUncontrolledModeProps<Name, Value> | ControlledModeProps<Name, Value>;
/**
 * Since MixedControlProps requires either value or defaultValue to be passed
 *(to make the choice of controlled vs uncontrolled explicitly)
 * we need other type that will allow the situation that you don't need to pass anything
 * and the defaultValue is set in the component.
 * In some cases this is useful (ie. DropdownMenu - most of people don't need to know that you can control focusedId
 * so why we should ask to provide
 * either defaultFocusedId or focusedId).
 * But use this with only for props that are very optional,
 * not related to props supposed to be used by the component consumer.
 */
export declare type ImplicitMixedControlProps<Name extends AllowedFieldNames, Value> = ImplicitUncontrolledModeProps<Name, Value> | ControlledModeProps<Name, Value>;
/**
 * In rare cases we also allow that the component has uncontrolled mode but we want to allow to listen for the change.
 * For example: DropdownMenu's onSelect - once it is opened, we just want to know which menu item was selected.
 * Use with caution.
 * Don't use the callback to synchronize the parent state in uncontrolled mode (without proving a setter).
 */
export declare type ImplicitTraceableMixedControlProps<Name extends AllowedFieldNames, Value> = ImplicitTraceableUncontrolledModeProps<Name, Value> | ControlledModeProps<Name, Value>;
export {};
