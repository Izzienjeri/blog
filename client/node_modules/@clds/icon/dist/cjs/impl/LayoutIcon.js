"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LayoutIcon = exports.getMemoizedLayoutIcon = void 0;
const tslib_1 = require("tslib");
/* eslint-disable max-len */
const react_1 = require("react");
const styled_components_1 = tslib_1.__importDefault(require("styled-components"));
const layoutIcons = new Map();
const paddingByIconSize = {
    18: 1,
    24: 4,
    36: 3,
    48: 0,
};
const createLayoutIcon = (iconComponent) => (0, styled_components_1.default)(iconComponent) `
    width: ${(props) => Number(props.iconSize) + 2 * paddingByIconSize[props.iconSize]}px;
    height: ${(props) => Number(props.iconSize) + 2 * paddingByIconSize[props.iconSize]}px;
    padding: ${(props) => paddingByIconSize[props.iconSize]}px;
  `;
const getMemoizedLayoutIcon = (iconComponent) => {
    if (!layoutIcons.has(iconComponent)) {
        const newIcon = createLayoutIcon(iconComponent);
        layoutIcons.set(iconComponent, newIcon);
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return layoutIcons.get(iconComponent);
};
exports.getMemoizedLayoutIcon = getMemoizedLayoutIcon;
/**
 * Component that tweaks existing icon components.
 * It resizes icons to match industry standard size and adds extra padding in order to align with
 * design system layout tokens.
 * @experimental Use it carefully, please report any feedback to #design-system channel.
 * Please note that this may break the layout if non-standard spacing is provided in the theme.
 * @param iconComponent the original icon component to tweak. All props will be passed to it.
 */
// eslint-disable-next-line react/prefer-stateless-function
class LayoutIcon extends react_1.Component {
    /**
     * If you wonder why this is an old-fashioned class function, it is due to styled components:
     * https://github.com/styled-components/styled-components/blob/061736aa6dbaf8e21168db1c07bb2d061d9f2546/packages/styled-components/src/utils/checkDynamicCreation.ts#L35
     * They warn about dynamic component creation to early prevent common mistake that developers make.
     * We want to create them lazily (with memoization) since we don't want to depend statically on any icon.
     * We also don't want to affect official API since this component is experimental only.
     */
    render() {
        const _a = this.props, { iconComponent } = _a, rest = tslib_1.__rest(_a, ["iconComponent"]);
        return (0, react_1.createElement)((0, exports.getMemoizedLayoutIcon)(iconComponent), rest);
    }
}
exports.LayoutIcon = LayoutIcon;
//# sourceMappingURL=LayoutIcon.js.map