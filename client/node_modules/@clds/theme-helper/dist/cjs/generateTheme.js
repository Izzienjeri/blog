"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTheme = void 0;
const tslib_1 = require("tslib");
const deepmerge_1 = tslib_1.__importDefault(require("deepmerge"));
const lodash_1 = require("lodash");
const themes_1 = tslib_1.__importDefault(require("@clds/themes"));
const isParentNode = (value) => typeof value === 'object';
const isThemeValue = (value) => Boolean(value) && ((0, lodash_1.isString)(value) || (0, lodash_1.isNumber)(value));
const resolveThemeLeaf = (theme, nodeValue, foundKeys = new Set()) => {
    const value = (0, lodash_1.get)(theme, nodeValue === null || nodeValue === void 0 ? void 0 : nodeValue.toString());
    if (!isThemeValue(value)) {
        return nodeValue;
    }
    if (foundKeys.has(nodeValue)) {
        throw new Error(`Cyclic theme references: ${JSON.stringify(foundKeys)}`);
    }
    console.error(`Found legacy string reference: "${nodeValue.toString()}" Please contact infra team!`);
    foundKeys.add(nodeValue);
    return resolveThemeLeaf(theme, value, foundKeys);
};
/**
 * It resolves theme node recursively down to leaves.
 * @param node theme node to resolve
 * @param theme whole theme object that is being used to resolve path-like values
 */
const transformThemeNode = (node, theme) => {
    if ((0, lodash_1.isObject)(node)) {
        const mappedNode = (0, lodash_1.mapValues)(node, (value, key) => transformThemeNode(node[key], theme));
        return Object.assign(Object.assign({}, node), mappedNode);
    }
    return resolveThemeLeaf(theme, node);
};
/**
 * Generates full theme object that can be placed directly into theme context.
 * It uses `deepmerge` library which preserves tree nodes that use Symbol as a key.
 * @param themes any number of theme overrides
 * @return deeply merged default theme and overrides,
 * also with all string references to other parts in the theme being resolved
 * (like 'spacing.xs' -> '0.5rem')
 */
const generateTheme = (...themes) => {
    const _a = deepmerge_1.default.all([
        themes_1.default,
        ...themes,
    ]), { components } = _a, theme = tslib_1.__rest(_a, ["components"]);
    const transformedTheme = transformThemeNode(theme, theme);
    if (!isParentNode(transformedTheme)) {
        throw new Error(`Transforming incorrect theme - "${JSON.stringify(theme)}"`);
    }
    return Object.assign(Object.assign({}, transformedTheme), { components });
};
exports.generateTheme = generateTheme;
//# sourceMappingURL=generateTheme.js.map