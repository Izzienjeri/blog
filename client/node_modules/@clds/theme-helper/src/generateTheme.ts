import deepmerge from 'deepmerge';
import { get, isNumber, isObject, isString, mapValues } from 'lodash';

import defaultTheme from '@clds/themes';

// Right now we don't have good way to make generic typing for that function
export type Leaf = string | number | boolean;
export type Node = Leaf | ParentNode;
export interface ParentNode {
  [key: string]: Node;
}
export type Theme = ParentNode;

const isParentNode = (value: unknown): value is ParentNode =>
  typeof value === 'object';
const isThemeValue = (value: unknown): value is Leaf =>
  Boolean(value) && (isString(value) || isNumber(value));

const resolveThemeLeaf = (
  theme: Theme,
  nodeValue: Node,
  foundKeys = new Set(),
): Node => {
  const value = get(theme, nodeValue?.toString());
  if (!isThemeValue(value)) {
    return nodeValue;
  }
  if (foundKeys.has(nodeValue)) {
    throw new Error(`Cyclic theme references: ${JSON.stringify(foundKeys)}`);
  }

  console.error(
    `Found legacy string reference: "${nodeValue.toString()}" Please contact infra team!`,
  );

  foundKeys.add(nodeValue);
  return resolveThemeLeaf(theme, value, foundKeys);
};

/**
 * It resolves theme node recursively down to leaves.
 * @param node theme node to resolve
 * @param theme whole theme object that is being used to resolve path-like values
 */
const transformThemeNode = (node: Node, theme: Theme): Node => {
  if (isObject(node)) {
    const mappedNode = mapValues(node, (value, key) =>
      transformThemeNode(node[key], theme),
    );

    return {
      ...node, // workaround - preserves Symbol() keys (although they are not mapped). Needed for @clds/component-theme
      ...mappedNode,
    };
  }
  return resolveThemeLeaf(theme, node);
};

/**
 * Generates full theme object that can be placed directly into theme context.
 * It uses `deepmerge` library which preserves tree nodes that use Symbol as a key.
 * @param themes any number of theme overrides
 * @return deeply merged default theme and overrides,
 * also with all string references to other parts in the theme being resolved
 * (like 'spacing.xs' -> '0.5rem')
 */
export const generateTheme = (...themes: Array<Theme>): Theme => {
  const { components, ...theme } = deepmerge.all<Theme>([
    defaultTheme,
    ...themes,
  ]);
  const transformedTheme = transformThemeNode(theme, theme);

  if (!isParentNode(transformedTheme)) {
    throw new Error(
      `Transforming incorrect theme - "${JSON.stringify(theme)}"`,
    );
  }

  return { ...transformedTheme, components };
};
