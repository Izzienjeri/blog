import { assert } from 'chai';

import { createTheme } from '../../src/api/createTheme';
import { createVariant } from '../../src/api/createVariant';
import { MixinProps } from '../../src/types';

describe('createVariant', () => {
  it('produces a mixin creator with derived mixin', () => {
    type Props = MixinProps<{
      shape: 'solid' | 'pill';
      type: 'primary' | 'secondary';
    }>;

    const themeConfig = {
      solid: {
        primary: {
          value: 'solidPrimaryValue',
        },
        secondary: {
          value: 'solidSecondaryValue',
        },
      },
      pill: {
        primary: {
          value: 'pillPrimaryValue',
        },
        secondary: {
          value: 'pillSecondaryValue',
        },
      },
    };
    const theme = createTheme(themeConfig);

    const variant = createVariant(
      (props: Props) => theme[props.shape][props.type],
    );

    type ExpectedType = (props: Props) => string;

    const mixin: ExpectedType = variant((value) => value.value);

    assert.strictEqual(
      mixin({ type: 'primary', shape: 'pill', theme: {} }),
      'pillPrimaryValue',
    );
    assert.strictEqual(
      mixin({ type: 'primary', shape: 'solid', theme: {} }),
      'solidPrimaryValue',
    );
    assert.strictEqual(
      mixin({ type: 'secondary', shape: 'pill', theme: {} }),
      'pillSecondaryValue',
    );
    assert.strictEqual(
      mixin({ type: 'secondary', shape: 'solid', theme: {} }),
      'solidSecondaryValue',
    );
  });

  it('should work with optional calculator - just return the branch', () => {
    type Props = MixinProps<{
      shape: 'solid' | 'pill';
      type: 'primary' | 'secondary';
    }>;

    const themeConfig = {
      solid: {
        primary: 'solidPrimaryValue',
        secondary: 'solidSecondaryValue',
      },
      pill: {
        primary: 'pillPrimaryValue',
        secondary: 'pillSecondaryValue',
      },
    };
    const theme = createTheme(themeConfig);

    const variant = createVariant(
      (props: Props) => theme[props.shape][props.type],
    );

    type ExpectedType = (props: Props) => string;

    const mixin: ExpectedType = variant();

    assert.strictEqual(
      mixin({ type: 'primary', shape: 'pill', theme: {} }),
      'pillPrimaryValue',
    );
    assert.strictEqual(
      mixin({ type: 'primary', shape: 'solid', theme: {} }),
      'solidPrimaryValue',
    );
    assert.strictEqual(
      mixin({ type: 'secondary', shape: 'pill', theme: {} }),
      'pillSecondaryValue',
    );
    assert.strictEqual(
      mixin({ type: 'secondary', shape: 'solid', theme: {} }),
      'solidSecondaryValue',
    );
  });
});
