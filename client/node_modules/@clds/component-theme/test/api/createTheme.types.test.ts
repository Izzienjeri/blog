/* eslint-disable @typescript-eslint/consistent-type-definitions, @typescript-eslint/no-explicit-any */
import {
  ConvertLiteralToPrimitive,
  MappedNode,
  Mixin,
  MixinToReturnValue,
} from '../../src/api/createTheme.types';
import { globalTheme } from '../../src/api/globalTheme';
import { MixinProps } from '../../src/types';

type Equals<A, B> = A extends B ? (B extends A ? 'pass' : 'failed') : 'failed';

// eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
const assertEqual = <A, B, C = Equals<A, B>>(_result: C) => {};

describe('TS type tests only - compile time', () => {
  it('ConvertLiteralToPrimitive', () => {
    interface Input {
      foo: 123;
      bar: string;
      baz: 'asd';
      deep: {
        foo: 123;
        bar: number;
        baz: false;
      };
    }
    type Result = ConvertLiteralToPrimitive<Input>;
    interface Expected {
      foo: number;
      bar: string;
      baz: string;
      deep: {
        foo: number;
        bar: number;
        baz: boolean;
      };
    }
    assertEqual<Expected, Result>('pass');
  });

  describe('MixinToReturnValue', () => {
    it('primitive', () => {
      type Input = string;
      type Result = MixinToReturnValue<Input>;
      type Expected = string;
      assertEqual<Expected, Result>('pass');
    });
    it('leaf mixin', () => {
      type Input = () => number;
      type Result = MixinToReturnValue<Input>;
      type Expected = number;
      assertEqual<Expected, Result>('pass');
    });
    it('parent mixin', () => {
      type Input = (() => { thisIsNotImportant: boolean }) & {
        foo: () => string;
        bar: () => string;
      };
      type Result = MixinToReturnValue<Input>;
      interface Expected {
        foo: string;
        bar: string;
      }
      assertEqual<Expected, Result>('pass');
    });
    it('child mixin', () => {
      interface Input {
        color: () => string;
      }

      type Result = MixinToReturnValue<Input>;

      interface Expected {
        color: string;
      }
      assertEqual<Expected, Result>('pass');
    });
    it('complex value', () => {
      interface Input {
        test: number;
        color: () => string;
        deep: { foo: string; bar: string; color: () => string } & (() => {
          notImportant: string;
        });
      }

      type Result = MixinToReturnValue<Input>;

      interface Expected {
        test: number;
        color: string;
        deep: {
          foo: string;
          bar: string;
          color: string;
        };
      }
      assertEqual<Expected, Result>('pass');
    });
  });

  describe('MappedNode', () => {
    it('maps leaf to mixin', () => {
      type Input = 'a literal';
      type Result = MappedNode<Input>;
      type Expected = Mixin<'a literal'>;

      assertEqual<Expected, Result>('pass');
    });

    it('maps mixin to mixin', () => {
      // this is the case when we override something which already references to mixin
      // (the implementation is different (override lookup)) but return type is the same
      type Input = (props: MixinProps<any, any>) => number;
      type Result = MappedNode<Input>;
      type Expected = Mixin<number>;

      assertEqual<Expected, Result>('pass');
    });

    it('maps global mixin to mixin', () => {
      // this is the case when we override something which already references to mixin
      // (the implementation is different (override lookup)) but return type is the same
      type Input = typeof globalTheme.palette.error;
      type Result = MappedNode<Input>;
      type Expected = Mixin<string>;

      assertEqual<Expected, Result>('pass');
    });

    it('maps tree to tree mixin', () => {
      interface Input {
        foo: string;
        bar: number;
        baz: { foobar: boolean };
      }
      type Result = MappedNode<Input>;
      type Expected = Mixin<Input> & {
        foo: Mixin<Input['foo']>;
        bar: Mixin<Input['bar']>;
        baz: Mixin<Input['baz']> & {
          foobar: Mixin<Input['baz']['foobar']>;
        };
      };

      assertEqual<Expected, Result>('pass');
    });

    it('maps tree with mixins to tree mixin', () => {
      type StringMixin = (props: MixinProps<any, any>) => string;
      type NumberMixin = (props: MixinProps<any, any>) => number;
      interface Input {
        foo: StringMixin;
        bar: NumberMixin;
        baz: { foobar: boolean };
      }
      type Result = MappedNode<Input>;
      type Expected = Mixin<{
        foo: string;
        bar: number;
        baz: { foobar: boolean };
      }> & {
        foo: Mixin<string>;
        bar: Mixin<number>;
        baz: Mixin<Input['baz']> & {
          foobar: Mixin<Input['baz']['foobar']>;
        };
      };

      assertEqual<Expected, Result>('pass');
    });
  });
});
