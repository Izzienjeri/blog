/* eslint-disable @typescript-eslint/no-unsafe-return,
   @typescript-eslint/no-unsafe-call,
   @typescript-eslint/no-unsafe-member-access,
   no-unused-vars
*/
import { get } from 'lodash';
import { themeNotFoundMessage } from './themeNotFoundMessage';
import { mapTree } from '../tree/mapTree';
import { resolveValue } from '../utils/resolveValue';
export const idField = Symbol();
const createThemePrecompile = (id, node) => {
    const cache = new WeakMap();
    const compileTheme = (theme) => mapTree(node, (node, leafPath) => resolveValue(id, node, leafPath, { theme }));
    return {
        getCompiledTheme: (theme) => {
            if (cache.has(theme)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return cache.get(theme);
            }
            const compiledTheme = compileTheme(theme);
            cache.set(theme, compiledTheme);
            return compiledTheme;
        },
    };
};
export const createTheme = (definition, id = Symbol('unique id of component theme')) => {
    const precompiledThemes = createThemePrecompile(id, definition);
    const createMixinForNode = (node, currentPath) => (props) => {
        if (props.theme === undefined) {
            throw new Error(themeNotFoundMessage);
        }
        const compiledTheme = precompiledThemes.getCompiledTheme(props.theme);
        return currentPath === ''
            ? compiledTheme
            : get(compiledTheme, currentPath);
    };
    const mixinTree = mapTree(definition, createMixinForNode, undefined, true, (currentPath) => ({
        toString: () => `mixins.${currentPath}`,
    }));
    mixinTree[idField] = id;
    mixinTree.toString = () => JSON.stringify(definition, (key, value) => (typeof value === 'function' ? value.toString() : value), ' ');
    return mixinTree;
};
export const overrideTheme = (theme, override) => ({
    [theme[idField]]: override,
});
//# sourceMappingURL=createTheme.js.map