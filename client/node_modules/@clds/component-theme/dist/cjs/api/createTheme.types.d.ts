/**
 * Some tree nodes are not aimed to be mapped. If the 'theme override' refers to existing styled mixin
 * (ie. mixins.palette.primary)
 * we want the mixin to be unchanged
 */
import { Leaf, MixinFunction, MixinProps, Node, ParentNode, ThemeWithOverrides } from '../types';
export interface Mixin<NodeType extends Node> {
    <PropsType, ThemeType extends ThemeWithOverrides>(props: MixinProps<PropsType, ThemeType>): ConvertLiteralToPrimitive<NodeType>;
}
/**
 * Type that extract primitive type from literal for deep tree of primitives
 * - from number literal - number type
 * - from string literal - string type
 * - from boolean literal - boolean type
 */
export declare type ConvertLiteralToPrimitive<T extends Node> = T extends MixinFunction ? T : T extends number ? number : T extends string ? string : T extends boolean ? boolean : T extends ParentNode ? {
    [Key in keyof T]: ConvertLiteralToPrimitive<T[Key]>;
} : T;
export interface NodeToMixinMapper {
    (node: Node, currentPath: string): Mixin<Node>;
}
export declare type MappedChildren<NodeType extends ParentNode> = {
    [Key in keyof NodeType]: MappedNode<NodeType[Key]>;
};
/**
 We want to transform tree of mixed types (values and mixins) to just values (mixins=>return type)
 If the mixin is a function, replace with returned value and repeat the conversions
 FIXME simplify  - maybe conditional infer will help
 */
export declare type MixinToReturnValue<NodeType extends Node> = NodeType extends MixinFunction ? ReturnType<NodeType> extends Leaf ? ReturnType<NodeType> : NodeType extends ParentNode ? {
    [Key in keyof NodeType]: MixinToReturnValue<NodeType[Key]>;
} : NodeType : NodeType extends ParentNode ? {
    [Key in keyof NodeType]: MixinToReturnValue<NodeType[Key]>;
} : NodeType;
/**
 * We want that every intermediate mixin will return a subtree but with all mixins resolved
 */
export declare type Compiled<NodeType extends MixinFunction> = Mixin<MixinToReturnValue<ReturnType<NodeType>>>;
export declare type MappedNode<NodeType extends Node> = NodeType extends Leaf ? (NodeType extends MixinFunction ? Compiled<NodeType> : NodeType extends boolean ? Mixin<boolean> : Mixin<NodeType>) : NodeType extends ParentNode ? (// parent node
Compiled<Mixin<NodeType>> & MappedChildren<NodeType>) : never;
export declare type Override<NodeType> = NodeType extends Leaf ? NodeType extends MixinFunction ? NodeType | ReturnType<NodeType> : NodeType | Mixin<NodeType> : {
    [Key in keyof NodeType]?: Override<NodeType[Key]>;
};
