/**
 * Some tree nodes are not aimed to be mapped. If the 'theme override' refers to existing styled mixin
 * (ie. mixins.palette.primary)
 * we want the mixin to be unchanged
 */
import {
  Leaf,
  MixinFunction,
  MixinProps,
  Node,
  ParentNode,
  ThemeWithOverrides,
} from '../types';

export interface Mixin<NodeType extends Node> {
  <PropsType, ThemeType extends ThemeWithOverrides>(
    props: MixinProps<PropsType, ThemeType>,
  ): ConvertLiteralToPrimitive<NodeType>;
}
/**
 * Type that extract primitive type from literal for deep tree of primitives
 * - from number literal - number type
 * - from string literal - string type
 * - from boolean literal - boolean type
 */
export type ConvertLiteralToPrimitive<T extends Node> = T extends MixinFunction
  ? T
  : T extends number
  ? number
  : T extends string
  ? string
  : T extends boolean
  ? boolean
  : T extends ParentNode
  ? {
      [Key in keyof T]: ConvertLiteralToPrimitive<T[Key]>;
    }
  : T;

export interface NodeToMixinMapper {
  (node: Node, currentPath: string): Mixin<Node>;
}

export type MappedChildren<NodeType extends ParentNode> = {
  [Key in keyof NodeType]: MappedNode<NodeType[Key]>;
};

/**
 We want to transform tree of mixed types (values and mixins) to just values (mixins=>return type)
 If the mixin is a function, replace with returned value and repeat the conversions
 FIXME simplify  - maybe conditional infer will help
 */
export type MixinToReturnValue<NodeType extends Node> =
  NodeType extends MixinFunction
    ? ReturnType<NodeType> extends Leaf
      ? ReturnType<NodeType>
      : NodeType extends ParentNode
      ? {
          [Key in keyof NodeType]: MixinToReturnValue<NodeType[Key]>;
        }
      : NodeType
    : NodeType extends ParentNode
    ? {
        [Key in keyof NodeType]: MixinToReturnValue<NodeType[Key]>;
      }
    : NodeType;

/**
 * We want that every intermediate mixin will return a subtree but with all mixins resolved
 */
export type Compiled<NodeType extends MixinFunction> = Mixin<
  MixinToReturnValue<ReturnType<NodeType>>
>;

// prettier-ignore
export type MappedNode<NodeType extends Node> =
  NodeType extends Leaf
    ? ( // leaf node
        NodeType extends MixinFunction
          ? Compiled<NodeType>
          : NodeType extends boolean // special case that avoids output type Mixin<false> | Mixin<true>
          ? Mixin<boolean>
          : Mixin<NodeType>
      )
  :NodeType extends ParentNode
    ? ( // parent node
        Compiled<Mixin<NodeType>> & MappedChildren<NodeType>
      )
  :never

export type Override<NodeType> = NodeType extends Leaf
  ? NodeType extends MixinFunction
    ? NodeType | ReturnType<NodeType>
    : NodeType | Mixin<NodeType>
  : {
      [Key in keyof NodeType]?: Override<NodeType[Key]>;
    };
