/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
import { MappedNode, NodeMapper } from './mapTree.types';
import { Node } from '../types';
import { isParent } from '../utils/isParent';

type NodeFactory = (currentPath: string) => Record<string, unknown> | undefined;

export const mapTree = <
  NodeType extends Node,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  MapperType extends NodeMapper<any>,
>(
  node: NodeType,
  mapper: MapperType,
  currentPath?: string,
  mapParents = false,
  nodeFactory: NodeFactory = () => undefined,
): MappedNode<NodeType, ReturnType<MapperType>> => {
  const nodeIsParent = isParent(node);
  const nodeIsLeaf = !nodeIsParent;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
  const mappedNode =
    mapParents || nodeIsLeaf ? mapper(node, currentPath || '') : {};
  Object.assign(mappedNode, nodeFactory(currentPath || ''));

  if (nodeIsParent) {
    for (const key in node) {
      // istanbul ignore else
      if (Object.prototype.hasOwnProperty.call(node, key)) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        mappedNode[key] = mapTree(
          node[key],
          mapper,
          currentPath ? currentPath + '.' + key : key,
          mapParents,
          nodeFactory,
        );
      }
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  return mappedNode as MappedNode<NodeType, ReturnType<MapperType>>;
};
