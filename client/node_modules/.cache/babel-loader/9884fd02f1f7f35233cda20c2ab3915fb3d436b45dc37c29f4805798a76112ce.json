{"ast":null,"code":"function n(n, r, t) {\n  return {\n    r: 255 * t(n.r / 255, r.r / 255),\n    g: 255 * t(n.g / 255, r.g / 255),\n    b: 255 * t(n.b / 255, r.b / 255)\n  };\n}\nfunction r(n, r) {\n  return r;\n}\nfunction t(n, r) {\n  return n * r;\n}\nfunction u(n, r) {\n  return n + r - n * r;\n}\nfunction i(n, r) {\n  return a(r, n);\n}\nfunction o(n, r) {\n  return Math.min(n, r);\n}\nfunction e(n, r) {\n  return Math.min(Math.max(n, r), 1);\n}\nfunction c(n, r) {\n  return 0 === n ? 0 : 1 === r ? 1 : Math.min(1, n / (1 - r));\n}\nfunction f(n, r) {\n  return 1 === n ? 1 : 0 === r ? 0 : 1 - Math.min(1, (1 - n) / r);\n}\nfunction a(n, r) {\n  return r <= .5 ? t(n, 2 * r) : u(n, 2 * r - 1);\n}\nfunction b(n, r) {\n  return r <= .5 ? n - (1 - 2 * r) * n * (1 - n) : n + (2 * r - 1) * ((n <= .25 ? ((16 * n - 12) * n + 4) * n : Math.sqrt(n)) - n);\n}\nfunction g(n, r) {\n  return Math.abs(n - r);\n}\nfunction h(n, r) {\n  return n + r - 2 * n * r;\n}\nfunction M(n, r, t) {\n  return Math.min(Math.max(n || 0, r), t);\n}\nfunction m(n) {\n  return {\n    r: M(n.r, 0, 255),\n    g: M(n.g, 0, 255),\n    b: M(n.b, 0, 255),\n    a: M(n.a, 0, 1)\n  };\n}\nfunction d(n) {\n  return {\n    r: 255 * n.r,\n    g: 255 * n.g,\n    b: 255 * n.b,\n    a: n.a\n  };\n}\nfunction p(n) {\n  return {\n    r: n.r / 255,\n    g: n.g / 255,\n    b: n.b / 255,\n    a: n.a\n  };\n}\nfunction v(n, r) {\n  void 0 === r && (r = 0);\n  var t = Math.pow(10, r);\n  return {\n    r: Math.round(n.r * t) / t,\n    g: Math.round(n.g * t) / t,\n    b: Math.round(n.b * t) / t,\n    a: n.a\n  };\n}\nfunction x(n, r, t, u, i, o) {\n  return (1 - r / t) * u + r / t * Math.round((1 - n) * i + n * o);\n}\nfunction O(n, r, t, u, i) {\n  void 0 === i && (i = {\n    unitInput: !1,\n    unitOutput: !1,\n    roundOutput: !0\n  }), i.unitInput && (n = d(n), r = d(r)), n = m(n);\n  var o = (r = m(r)).a + n.a - r.a * n.a,\n    e = t(n, r, u),\n    c = m({\n      r: x(n.a, r.a, o, n.r, r.r, e.r),\n      g: x(n.a, r.a, o, n.g, r.g, e.g),\n      b: x(n.a, r.a, o, n.b, r.b, e.b),\n      a: o\n    });\n  return c = i.unitOutput ? p(c) : i.roundOutput ? v(c) : function (n) {\n    return v(n, 9);\n  }(c), c;\n}\nfunction s(n, r, t) {\n  return d(t(p(n), p(r)));\n}\nfunction I(n) {\n  return .3 * n.r + .59 * n.g + .11 * n.b;\n}\nfunction q(n, r) {\n  var t = r - I(n);\n  return function (n) {\n    var r = I(n),\n      t = n.r,\n      u = n.g,\n      i = n.b,\n      o = Math.min(t, u, i),\n      e = Math.max(t, u, i);\n    function c(n) {\n      return r + (n - r) * r / (r - o);\n    }\n    function f(n) {\n      return r + (n - r) * (1 - r) / (e - r);\n    }\n    return o < 0 && (t = c(t), u = c(u), i = c(i)), e > 1 && (t = f(t), u = f(u), i = f(i)), {\n      r: t,\n      g: u,\n      b: i\n    };\n  }({\n    r: n.r + t,\n    g: n.g + t,\n    b: n.b + t\n  });\n}\nfunction w(n) {\n  return Math.max(n.r, n.g, n.b) - Math.min(n.r, n.g, n.b);\n}\nfunction j(n, r) {\n  var t = [\"r\", \"g\", \"b\"].sort(function (r, t) {\n      return n[r] - n[t];\n    }),\n    u = t[0],\n    i = t[1],\n    o = t[2],\n    e = {\n      r: n.r,\n      g: n.g,\n      b: n.b\n    };\n  return e[o] > e[u] ? (e[i] = (e[i] - e[u]) * r / (e[o] - e[u]), e[o] = r) : e[i] = e[o] = 0, e[u] = 0, e;\n}\nfunction k(n, r) {\n  return q(j(r, w(n)), I(n));\n}\nfunction l(n, r) {\n  return q(j(n, w(r)), I(n));\n}\nfunction y(n, r) {\n  return q(r, I(n));\n}\nfunction z(n, r) {\n  return q(n, I(r));\n}\nfunction A(t, u) {\n  return O(t, u, n, r);\n}\nfunction B(r, u) {\n  return O(r, u, n, t);\n}\nfunction C(r, t) {\n  return O(r, t, n, u);\n}\nfunction D(r, t) {\n  return O(r, t, n, i);\n}\nfunction E(r, t) {\n  return O(r, t, n, o);\n}\nfunction F(r, t) {\n  return O(r, t, n, e);\n}\nfunction G(r, t) {\n  return O(r, t, n, c);\n}\nfunction H(r, t) {\n  return O(r, t, n, f);\n}\nfunction J(r, t) {\n  return O(r, t, n, a);\n}\nfunction K(r, t) {\n  return O(r, t, n, b);\n}\nfunction L(r, t) {\n  return O(r, t, n, g);\n}\nfunction N(r, t) {\n  return O(r, t, n, h);\n}\nfunction P(n, r) {\n  return O(n, r, s, k);\n}\nfunction Q(n, r) {\n  return O(n, r, s, l);\n}\nfunction R(n, r) {\n  return O(n, r, s, y);\n}\nfunction S(n, r) {\n  return O(n, r, s, z);\n}\nexport { R as color, H as colorBurn, G as colorDodge, E as darken, L as difference, N as exclusion, J as hardLight, P as hue, F as lighten, S as luminosity, B as multiply, A as normal, D as overlay, Q as saturation, C as screen, K as softLight };","map":{"version":3,"names":["n","r","t","g","b","u","i","a","o","Math","min","e","max","c","f","sqrt","abs","h","M","m","d","p","v","pow","round","x","O","unitInput","unitOutput","roundOutput","s","I","q","w","j","sort","k","l","y","z","A","B","C","D","E","F","G","H","J","K","L","N","P","Q","R","S","color","colorBurn","colorDodge","darken","difference","exclusion","hardLight","hue","lighten","luminosity","multiply","normal","overlay","saturation","screen","softLight"],"sources":["/home/angela/Development/code/flask/blog_app_project/client/node_modules/color-blend/src/separable-blend.ts","/home/angela/Development/code/flask/blog_app_project/client/node_modules/color-blend/src/separable-modes.ts","/home/angela/Development/code/flask/blog_app_project/client/node_modules/color-blend/src/helpers.ts","/home/angela/Development/code/flask/blog_app_project/client/node_modules/color-blend/src/non-separable-blend.ts","/home/angela/Development/code/flask/blog_app_project/client/node_modules/color-blend/src/non-separable-modes.ts","/home/angela/Development/code/flask/blog_app_project/client/node_modules/color-blend/src/index.ts"],"sourcesContent":["import { ChannelBlender, RGB, RGBA } from './types'\n\n/**\n * Blend two colors in a separable way (i.e. each color channel individually)\n *\n * @param backdrop The RGBA backdrop color\n * @param source   The RGBA source color\n * @param callback The blend mode callback to apply\n */\nexport default function separableBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  callback: ChannelBlender\n): RGB {\n  return {\n    r: callback(backdrop.r / 255, source.r / 255) * 255,\n    g: callback(backdrop.g / 255, source.g / 255) * 255,\n    b: callback(backdrop.b / 255, source.b / 255) * 255\n  }\n}\n","/**\n * Algorithms for separable blend modes (i.e. where the same algorithms is applied to each color channel)\n * @see https://www.w3.org/TR/compositing-1/#blendingseparable\n */\n\n/**\n * Blend two color channels with the \"normal\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\n// @ts-ignore the unused first parameter to comply with the interface\nexport function normal(backdrop: number, source: number) {\n  return source\n}\n\n/**\n * Blend two color channels with the \"multiply\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function multiply(backdrop: number, source: number) {\n  return backdrop * source\n}\n\n/**\n * Blend two color channels with the \"screen\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function screen(backdrop: number, source: number) {\n  return backdrop + source - backdrop * source\n}\n\n/**\n * Blend two color channels with the \"overlay\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function overlay(backdrop: number, source: number) {\n  return hardLight(source, backdrop)\n}\n\n/**\n * Blend two color channels with the \"darken\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function darken(backdrop: number, source: number) {\n  return Math.min(backdrop, source)\n}\n\n/**\n * Blend two color channels with the \"lighten\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function lighten(backdrop: number, source: number) {\n  return Math.min(Math.max(backdrop, source), 1)\n}\n\n/**\n * Blend two color channels with the \"color dodge\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function colorDodge(backdrop: number, source: number) {\n  return backdrop === 0\n    ? 0\n    : source === 1\n    ? 1\n    : Math.min(1, backdrop / (1 - source))\n}\n\n/**\n * Blend two color channels with the \"color burn\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function colorBurn(backdrop: number, source: number) {\n  return backdrop === 1\n    ? 1\n    : source === 0\n    ? 0\n    : 1 - Math.min(1, (1 - backdrop) / source)\n}\n\n/**\n * Blend two color channels with the \"hard light\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function hardLight(backdrop: number, source: number) {\n  return source <= 0.5\n    ? multiply(backdrop, 2 * source)\n    : screen(backdrop, 2 * source - 1)\n}\n\n/**\n * Blend two color channels with the \"soft light\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function softLight(backdrop: number, source: number) {\n  return source <= 0.5\n    ? backdrop - (1 - 2 * source) * backdrop * (1 - backdrop)\n    : backdrop +\n        (2 * source - 1) *\n          ((backdrop <= 0.25\n            ? ((16 * backdrop - 12) * backdrop + 4) * backdrop\n            : Math.sqrt(backdrop)) -\n            backdrop)\n}\n\n/**\n * Blend two color channels with the \"difference\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function difference(backdrop: number, source: number) {\n  return Math.abs(backdrop - source)\n}\n\n/**\n * Blend two color channels with the \"exclusion\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function exclusion(backdrop: number, source: number) {\n  return backdrop + source - 2 * backdrop * source\n}\n","import { ChannelBlender, NoAlphaBlender, RGB, RGBA } from './types'\n\n// Some utility (no actual blend-related algorithms) for color handling\n\n/**\n * Restricts a number to given boundaries\n * @param value The number to restrict\n * @param from  The lower boundary\n * @param to    The upper boundary\n * @return The restricted value\n */\nfunction restrictNumber(value: number, from: number, to: number) {\n  return Math.min(Math.max(value || 0, from), to)\n}\n\n/**\n * Restricts an { r,g,b,a } color to its boundaries (0..255 color channels, 0..1 alpha channel)\n * @param color The { r,g,b,a } color to restrict\n * @return The restricted color\n */\nfunction restrictColor(color: RGBA): RGBA {\n  return {\n    r: restrictNumber(color.r, 0, 255),\n    g: restrictNumber(color.g, 0, 255),\n    b: restrictNumber(color.b, 0, 255),\n    a: restrictNumber(color.a, 0, 1)\n  }\n}\n\n/**\n * Converts a color from unit color channels [0..1] to 8-bit color channels [0..255]\n * @param color The { r,g,b,a } color to convert\n * @return The { r,g,b,a } with 8-bit color channels\n */\nexport function convertFromUnit(color: RGBA): RGBA\nexport function convertFromUnit(color: RGB): RGB\nexport function convertFromUnit(color: any): RGB | RGBA {\n  return {\n    r: color.r * 255,\n    g: color.g * 255,\n    b: color.b * 255,\n    a: color.a\n  }\n}\n\n/**\n * Converts a color from 8-bit color channels [0..255] to unit color channels [0..1]\n * @param color The { r,g,b,a } color to convert\n * @return The { r,g,b,a } with unit color channels\n */\nexport function convertToUnit(color: RGBA): RGBA\nexport function convertToUnit(color: RGB): RGB\nexport function convertToUnit(color: any): RGB | RGBA {\n  return {\n    r: color.r / 255,\n    g: color.g / 255,\n    b: color.b / 255,\n    a: color.a\n  }\n}\n\n/**\n * Rounds the color channels of an RGBA color\n * @param color     The { r,g,b,a } color to handle\n * @param precision How many decimals? Defaults to 0\n * @return The { r,g,b,a } with rounded color channels\n */\nfunction roundChannels(color: RGBA, precision?: number): RGBA\nfunction roundChannels(color: RGB, precision?: number): RGB\nfunction roundChannels(color: any, precision: number = 0): RGB | RGBA {\n  const multiplier = Math.pow(10, precision)\n\n  return {\n    r: Math.round(color.r * multiplier) / multiplier,\n    g: Math.round(color.g * multiplier) / multiplier,\n    b: Math.round(color.b * multiplier) / multiplier,\n    a: color.a\n  }\n}\n\n/**\n * Rounds the color channels of an RGBA color with high precision to aviod IEEE 754 related issues\n * @param color The { r,g,b,a } color to handle\n * @return The { r,g,b,a } with rounded color channels\n */\nfunction roundChannelsBinaryFloat(color: RGBA): RGBA {\n  return roundChannels(color, 9)\n}\n\n/**\n * Applies the appropriate alpha blending to a blend process.\n * @see https://www.w3.org/TR/compositing-1/#blending\n * @param backdropAlpha  The alpha channel of the backdrop color [0..1]\n * @param sourceAlpha    The alpha channel of the source color [0..1]\n * @param compositeAlpha The alpha channel of the composite color [0..1]\n * @param backdropColor  A color channel (R, G or B) of the backdrop color [0..255]\n * @param sourceColor    A color channel (R, G or B) of the source color [0..255]\n * @param compositeColor A color channel (R, G or B) of the composite color [0..255]\n * @return The resulting color channel\n */\nfunction alphaCompose(\n  backdropAlpha: number,\n  sourceAlpha: number,\n  compositeAlpha: number,\n  backdropColor: number,\n  sourceColor: number,\n  compositeColor: number\n) {\n  return (\n    (1 - sourceAlpha / compositeAlpha) * backdropColor +\n    (sourceAlpha / compositeAlpha) *\n      Math.round(\n        (1 - backdropAlpha) * sourceColor + backdropAlpha * compositeColor\n      )\n  )\n}\n\nexport interface BlendOptions {\n  unitInput: boolean\n  unitOutput: boolean\n  roundOutput: boolean\n}\n\n/**\n * Blend two colors\n * All RGBA objects are { r,g,b,a } with [0..255] for RGB and [0..1] for alpha\n * @param source               The { r,g,b,a } color to be put on top\n * @param backdrop             The { r,g,b,a } color to be put below the source\n * @param abstractModeCallback The abstract blend mode function (separable vs. non-separable)\n * @param concreteModeCallback The concrete blend mode function (normal, multiply, ...)\n * @param options              The options to apply\n * @return The { r,g,b,a } result object, channel values are not rounded\n */\nexport function performBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  abstractModeCallback: (\n    backdrop: RGBA,\n    source: RGBA,\n    concreteModeCallback: ChannelBlender\n  ) => RGB,\n  concreteModeCallback: ChannelBlender,\n  options?: Partial<BlendOptions>\n): RGBA\nexport function performBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  abstractModeCallback: (\n    backdrop: RGBA,\n    source: RGBA,\n    concreteModeCallback: NoAlphaBlender\n  ) => RGB,\n  concreteModeCallback: NoAlphaBlender,\n  options?: Partial<BlendOptions>\n): RGBA\nexport function performBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  abstractModeCallback: (\n    backdrop: RGBA,\n    source: RGBA,\n    concreteModeCallback: any\n  ) => RGB,\n  concreteModeCallback: ChannelBlender | NoAlphaBlender,\n  options: Partial<BlendOptions> = {\n    unitInput: false,\n    unitOutput: false,\n    roundOutput: true\n  }\n) {\n  // Handle unit input if needed\n  if (options.unitInput) {\n    backdrop = convertFromUnit(backdrop)\n    source = convertFromUnit(source)\n  }\n\n  // Remove out-of-bounds values\n  backdrop = restrictColor(backdrop)\n  source = restrictColor(source)\n\n  // Calculate resulting alpha\n  const a = source.a + backdrop.a - source.a * backdrop.a\n\n  // Calculate resulting RGB\n  const resultRGB = abstractModeCallback(backdrop, source, concreteModeCallback)\n\n  // Calculate actual RGBs from backdrop, source and result + alpha values\n  // Since blending may result in out-of-bounds color channels, cut those\n  let resultRGBA = restrictColor({\n    r: alphaCompose(backdrop.a, source.a, a, backdrop.r, source.r, resultRGB.r),\n    g: alphaCompose(backdrop.a, source.a, a, backdrop.g, source.g, resultRGB.g),\n    b: alphaCompose(backdrop.a, source.a, a, backdrop.b, source.b, resultRGB.b),\n    a: a\n  })\n\n  // Convert color channels to unit values if needed\n  if (options.unitOutput) {\n    resultRGBA = convertToUnit(resultRGBA)\n\n    // Round 8-bit color channels if needed\n  } else if (options.roundOutput) {\n    resultRGBA = roundChannels(resultRGBA)\n\n    // Round anyways to get rid of JavaScript floating point issues\n  } else {\n    resultRGBA = roundChannelsBinaryFloat(resultRGBA)\n  }\n\n  return resultRGBA\n}\n","import { convertFromUnit, convertToUnit } from './helpers'\nimport { NoAlphaBlender, RGBA } from './types'\n\n/**\n * Blend two colors in a non-separable way\n *\n * @param backdrop The background color as an { r,g,b,a } object\n * @param source   The foreground color as an { r,g,b,a } object\n * @param callback The blend mode callback to apply\n */\nexport default function nonSeparableBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  callback: NoAlphaBlender\n) {\n  return convertFromUnit(\n    callback(convertToUnit(backdrop), convertToUnit(source))\n  )\n}\n","/**\n * Algorithms for non-separable blend modes (based on HSV/HSL color space)\n * @see https://www.w3.org/TR/compositing-1/#blendingnonseparable\n */\n\nimport { RGB } from './types'\n\n/**\n * Get the luminosity of a color\n *\n * @param rgb The color as an { r,g,b } object with each channel as a fraction\n */\nfunction getLuminosity(rgb: RGB) {\n  return 0.3 * rgb.r + 0.59 * rgb.g + 0.11 * rgb.b\n}\n\n/**\n * Clip the channels of a color\n *\n * @param rgb The color as an { r,g,b } object with each channel as a fraction\n */\nfunction clipColor(rgb: RGB): RGB {\n  const luminosity = getLuminosity(rgb)\n  let { r, g, b } = rgb\n\n  const lowestChannel = Math.min(r, g, b)\n  const highestChannel = Math.max(r, g, b)\n\n  function clipLowest(channel: number) {\n    return (\n      luminosity +\n      ((channel - luminosity) * luminosity) / (luminosity - lowestChannel)\n    )\n  }\n\n  function clipHighest(channel: number) {\n    return (\n      luminosity +\n      ((channel - luminosity) * (1 - luminosity)) /\n        (highestChannel - luminosity)\n    )\n  }\n\n  if (lowestChannel < 0) {\n    r = clipLowest(r)\n    g = clipLowest(g)\n    b = clipLowest(b)\n  }\n\n  if (highestChannel > 1) {\n    r = clipHighest(r)\n    g = clipHighest(g)\n    b = clipHighest(b)\n  }\n\n  return { r, g, b }\n}\n\n/**\n * Set luminosity on a color\n *\n * @param rgb        The color as an { r,g,b } object with each channel as a fraction\n * @param luminosity The luminosity to apply\n */\nfunction setLuminosity(rgb: RGB, luminosity: number) {\n  const delta = luminosity - getLuminosity(rgb)\n\n  return clipColor({\n    r: rgb.r + delta,\n    g: rgb.g + delta,\n    b: rgb.b + delta\n  })\n}\n\n/**\n * Get the saturation of a color\n *\n * @param rgb The color as an { r,g,b } object with each channel as a fraction\n */\nfunction getSaturation(rgb: RGB) {\n  return Math.max(rgb.r, rgb.g, rgb.b) - Math.min(rgb.r, rgb.g, rgb.b)\n}\n\n/**\n * Set saturation on a color\n *\n * @param rgb        The color as an { r,g,b } object with each channel as a fraction\n * @param saturation The saturation to apply\n */\nfunction setSaturation(rgb: RGB, saturation: number) {\n  const sortedChannels = ['r', 'g', 'b'].sort(\n    (a, b) => rgb[a as keyof RGB] - rgb[b as keyof RGB]\n  ) as [keyof RGB, keyof RGB, keyof RGB]\n  const channelMin = sortedChannels[0]\n  const channelMid = sortedChannels[1]\n  const channelMax = sortedChannels[2]\n\n  const result = {\n    r: rgb.r,\n    g: rgb.g,\n    b: rgb.b\n  }\n\n  if (result[channelMax] > result[channelMin]) {\n    result[channelMid] =\n      ((result[channelMid] - result[channelMin]) * saturation) /\n      (result[channelMax] - result[channelMin])\n    result[channelMax] = saturation\n  } else {\n    result[channelMid] = result[channelMax] = 0\n  }\n\n  result[channelMin] = 0\n\n  return result\n}\n\n/**\n * Blend two colors with the \"hue\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function hue(backdrop: RGB, source: RGB) {\n  return setLuminosity(\n    setSaturation(source, getSaturation(backdrop)),\n    getLuminosity(backdrop)\n  )\n}\n\n/**\n * Blend two colors with the \"saturation\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function saturation(backdrop: RGB, source: RGB) {\n  return setLuminosity(\n    setSaturation(backdrop, getSaturation(source)),\n    getLuminosity(backdrop)\n  )\n}\n\n/**\n * Blend two colors with the \"color\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function color(backdrop: RGB, source: RGB) {\n  return setLuminosity(source, getLuminosity(backdrop))\n}\n\n/**\n * Blend two colors with the \"luminosity\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function luminosity(backdrop: RGB, source: RGB) {\n  return setLuminosity(backdrop, getLuminosity(source))\n}\n","import separableBlend from './separable-blend'\nimport * as separableBlendModes from './separable-modes'\n\nimport nonSeparableBlend from './non-separable-blend'\nimport * as nonSeparableBlendModes from './non-separable-modes'\n\nimport { performBlend } from './helpers'\nimport { RGBA } from './types'\n\n/**\n * Blend two colors with the \"normal\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function normal(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.normal\n  )\n}\n\n/**\n * Blend two colors with the \"multiply\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function multiply(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.multiply\n  )\n}\n\n/**\n * Blend two colors with the \"screen\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function screen(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.screen\n  )\n}\n\n/**\n * Blend two colors with the \"overlay\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function overlay(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.overlay\n  )\n}\n\n/**\n * Blend two colors with the \"darken\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function darken(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.darken\n  )\n}\n\n/**\n * Blend two colors with the \"lighten\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function lighten(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.lighten\n  )\n}\n\n/**\n * Blend two colors with the \"color dodge\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function colorDodge(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.colorDodge\n  )\n}\n\n/**\n * Blend two colors with the \"color burn\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function colorBurn(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.colorBurn\n  )\n}\n\n/**\n * Blend two colors with the \"hard light\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function hardLight(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.hardLight\n  )\n}\n\n/**\n * Blend two colors with the \"soft light\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function softLight(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.softLight\n  )\n}\n\n/**\n * Blend two colors with the \"difference\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function difference(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.difference\n  )\n}\n\n/**\n * Blend two colors with the \"exclusion\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function exclusion(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.exclusion\n  )\n}\n\n/**\n * Blend two colors with the \"hue\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function hue(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.hue\n  )\n}\n\n/**\n * Blend two colors with the \"saturation\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function saturation(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.saturation\n  )\n}\n\n/**\n * Blend two colors with the \"color\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function color(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.color\n  )\n}\n\n/**\n * Blend two colors with the \"luminosity\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function luminosity(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.luminosity\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}